import { extractYouTubeVideoId, generateYouTubeEmbedHtml } from "../utils/youtube";
import { ContentTypeHandler } from "./ContentTypeHandler";
import { fetchYouTubeTranscript } from "../services/YouTubeTranscriptService";
import { YouTubeVideoData } from "../models/YouTubeVideoData";
import { requestUrl, RequestUrlResponse } from "obsidian";
import { extractTranscriptFromHtml } from "../services/YouTubeTranscriptService";
import { getLogger } from "../utils/importerLogger";
import { LLMOutput } from "../services/LLMProvider";

/**
 * Structured output for YouTube LLM responses, extending the base LLMOutput.
 */
export interface YouTubeLLMOutput extends LLMOutput {
  summary: string;
  keyPoints: string[];
  keyConcepts: string[];
}

/**
 * Handler for YouTube video content, implementing the ContentTypeHandler interface.
 * This handler is responsible for detecting YouTube URLs, generating LLM prompts for video summarization,
 * and parsing LLM markdown responses into structured output. All YouTube-specific prompt and parsing logic
 * is fully self-contained within this class, in compliance with the strategy-based architecture.
 */
export class YouTubeHandler implements ContentTypeHandler {
  public readonly type = "youtube";

  /**
   * The YouTube-specific prompt template for LLM summarization.
   * This template instructs the LLM to generate a comprehensive summary, key points, technical terms, and conclusion.
   */
  private static readonly YOUTUBE_PROMPT_TEMPLATE = `
You are a specialized assistant for creating comprehensive video summaries from subtitles. The subtitles have been automatically generated by YouTube and may contain transcription errors, especially with technical terms, software names, and specialized vocabulary.

## Task

Create a concise yet comprehensive summary of the video based on the provided subtitles.

## Handling Transcription Errors

- Correct obvious transcription errors based on context and your domain knowledge
- Pay special attention to technical terms, software names, programming languages, and IDE plugins which are frequently misrecognized
- If multiple interpretations are possible, choose the most likely one based on the video's context

## Output Structure

\`\`\`
## Summary
[Write a comprehensive summary of the main topic and key message]

## Key points
- [Key point 1]
- [Key point 2]
- [Additional key points...]

## Technical terms
- **[[Term 1]]**: [Explanation of term 1]
- **[[Term 2]]**: [Explanation of term 2]
- [Additional terms as needed...]

## Conclusion
[Write a brief conclusion]
\`\`\`

Note: Include all sections. If there are no technical terms, omit that section entirely.

Subtitles: {{transcript}}
`;

  /**
   * Determines if this handler can process the given URL.
   */
  detect(url: URL): boolean {
    const host = url.hostname.toLowerCase();
    return (
      host === "youtube.com" ||
      host === "www.youtube.com" ||
      host === "youtu.be" ||
      host === "www.youtu.be"
    );
  }

  /**
   * Generates the LLM prompt for YouTube video summarization, using the video transcript.
   */
  getPrompt(metadata: any): string {
    const transcript = metadata?.transcript || "";
    return YouTubeHandler.YOUTUBE_PROMPT_TEMPLATE.replace("{{transcript}}", transcript);
  }

  /**
   * Parses the LLM's markdown response into a structured output for YouTube videos.
   */
  parseLLMResponse(markdown: string): YouTubeLLMOutput {
    // Helper to extract section content by heading
    function extractSection(heading: string): string {
      const pattern = new RegExp(`^##\\s*${heading}\\s*\\n([\\s\\S]*?)(?=^##\\s|\\Z)`, 'im');
      const match = markdown.match(pattern);
      return match ? match[1].trim() : '';
    }

    // Helper to parse a Markdown list into array of strings
    function parseList(section: string): string[] {
      if (!section) return [];
      const lines = section.split('\n');
      const items: string[] = [];
      for (const line of lines) {
        const itemMatch = line.match(/^\s*(?:[-*]|\d+\.)\s+(.*)$/);
        if (itemMatch && itemMatch[1].trim()) {
          items.push(itemMatch[1].trim());
        }
      }
      if (items.length === 0 && section.trim()) {
        if (lines.length === 1) {
          items.push(section.trim());
        }
      }
      return items;
    }

    // Helper to parse technical terms section into array of strings (for keyConcepts)
    function parseTechnicalTermsAsStrings(section: string): string[] {
      if (!section) return [];
      const lines = section.split('\n');
      const terms: string[] = [];
      for (const line of lines) {
        const match = line.match(/^\s*[-*]\s+\*\*\[\[(.+?)\]\]\*\*:\s*(.+)$/);
        if (match) {
          terms.push(`${match[1].trim()}: ${match[2].trim()}`);
        }
      }
      return terms;
    }

    const summarySection = extractSection('Summary');
    const keyPointsSection = extractSection('Key points');
    const technicalTermsSection = extractSection('Technical terms');

    const result: YouTubeLLMOutput = {
      summary: summarySection,
      keyPoints: parseList(keyPointsSection),
      keyConcepts: parseTechnicalTermsAsStrings(technicalTermsSection),
    };
    this.validateLLMOutput(result);
    return result;
  }

  /**
   * Validates the structure and content of a YouTubeLLMOutput object.
   * Throws a descriptive error if invalid; returns true if valid.
   */
  public validateLLMOutput(output: LLMOutput): true {
    const ytOutput = output as YouTubeLLMOutput;
    if (!ytOutput || typeof ytOutput !== 'object') {
      throw new Error('YouTubeLLMOutput is missing or not an object.');
    }
    if (typeof ytOutput.summary !== 'string' || ytOutput.summary.trim() === '') {
      throw new Error('YouTubeLLMOutput.summary must be a non-empty string.');
    }
    if (!Array.isArray(ytOutput.keyPoints)) {
      throw new Error('YouTubeLLMOutput.keyPoints must be an array.');
    }
    if (ytOutput.keyPoints.length === 0) {
      throw new Error('YouTubeLLMOutput.keyPoints must contain at least one item.');
    }
    for (let i = 0; i < ytOutput.keyPoints.length; i++) {
      const point = ytOutput.keyPoints[i];
      if (typeof point !== 'string' || point.trim() === '') {
        throw new Error(`YouTubeLLMOutput.keyPoints[${i}] must be a non-empty string.`);
      }
    }
    if (!Array.isArray(ytOutput.keyConcepts)) {
      throw new Error('YouTubeLLMOutput.keyConcepts must be an array.');
    }
    if (ytOutput.keyConcepts.length === 0) {
      throw new Error('YouTubeLLMOutput.keyConcepts must contain at least one item.');
    }
    for (let i = 0; i < ytOutput.keyConcepts.length; i++) {
      const concept = ytOutput.keyConcepts[i];
      if (typeof concept !== 'string' || concept.trim() === '') {
        throw new Error(`YouTubeLLMOutput.keyConcepts[${i}] must be a non-empty string.`);
      }
    }
    return true;
  }

  /**
   * Downloads the YouTube transcript and extracts video metadata.
   */
  async download(url: string): Promise<{ content: string; metadata: YouTubeVideoData }> {
    const videoId = extractYouTubeVideoId(url);
    if (!videoId) {
      throw new Error("Invalid YouTube URL: cannot extract video ID");
    }

    const videoPageResponse: RequestUrlResponse = await requestUrl({ url: `https://www.youtube.com/watch?v=${videoId}` });
    const html = videoPageResponse.text;

    const transcript = await extractTranscriptFromHtml(html);

    function getMeta(name: string): string | undefined {
      const og = html.match(new RegExp(`<meta[^>]+property=[\"']og:${name}[\"'][^>]+content=[\"']([^\"']+)[\"']`, "i"));
      if (og) return og[1];
      const nameTag = html.match(new RegExp(`<meta[^>]+name=[\"']${name}[\"'][^>]+content=[\"']([^\"']+)[\"']`, "i"));
      return nameTag ? nameTag[1] : undefined;
    }

    const AUTHOR_REGEX = /"author":"([^"]+)"/;
    const CHANNEL_ID_REGEX = /"channelId":"([^"]+)"/;

    const title = getMeta("title") || "";
    const author = html.match(AUTHOR_REGEX)?.[1] || getMeta("video:director") || getMeta("site_name") || "";
    const authorUrl = html.match(CHANNEL_ID_REGEX)?.[1] || getMeta("video:director:url") || "";
    const thumbnailUrl = getMeta("image") || "";
    const providerName = getMeta("site_name") || "YouTube";
    const providerUrl = "https://www.youtube.com";
    const htmlEmbed = getMeta("video:url") ? generateYouTubeEmbedHtml(videoId) : "";
    const width = Number.parseInt(getMeta("video:width") || "560");
    const height = Number.parseInt(getMeta("video:height") || "315");

    let thumbnailWidth = 0, thumbnailHeight = 0;
    const thumbDimMatch = html.match(/<meta[^>]+property=[\"']og:image:width[\"'][^>]+content=[\"'](\d+)[\"']/i);
    if (thumbDimMatch) thumbnailWidth = parseInt(thumbDimMatch[1], 10);
    const thumbDimMatchH = html.match(/<meta[^>]+property=[\"']og:image:height[\"'][^>]+content=[\"'](\d+)[\"']/i);
    if (thumbDimMatchH) thumbnailHeight = parseInt(thumbDimMatchH[1], 10);

    const metadata: YouTubeVideoData = {
      videoId,
      title,
      author,
      authorUrl,
      thumbnailUrl,
      thumbnailWidth,
      thumbnailHeight,
      providerName,
      providerUrl,
      html: htmlEmbed,
      width,
      height,
      transcript
    };

    return { content: transcript, metadata };
  }

  /**
   * Returns the folder name for YouTube notes.
   */
  getFolderName(): string {
    return "YouTube";
  }

  /**
   * Generates the note content to be written to the file.
   */
  getNoteContent(markdown: string, metadata: YouTubeVideoData): string {
    const noteContent = [
      `# ${metadata.title}\n`,
      `![Thumbnail](${metadata.thumbnailUrl})\n`,
      `Author: [${metadata.author}](${metadata.authorUrl})\n`,
      `Video: [Watch here](https://www.youtube.com/watch?v=${metadata.videoId})\n`,
      markdown,
    ];
    return noteContent.join("\n");
  }
}